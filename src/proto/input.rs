// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `input.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Pos2)
pub struct Pos2 {
    // message fields
    // @@protoc_insertion_point(field:proto.Pos2.x)
    pub x: f32,
    // @@protoc_insertion_point(field:proto.Pos2.y)
    pub y: f32,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Pos2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pos2 {
    fn default() -> &'a Pos2 {
        <Pos2 as ::protobuf::Message>::default_instance()
    }
}

impl Pos2 {
    pub fn new() -> Pos2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &Pos2| { &m.x },
            |m: &mut Pos2| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &Pos2| { &m.y },
            |m: &mut Pos2| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pos2>(
            "Pos2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pos2 {
    const NAME: &'static str = "Pos2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = is.read_float()?;
                },
                21 => {
                    self.y = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 4;
        }
        if self.y != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pos2 {
        Pos2::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pos2 {
        static instance: Pos2 = Pos2 {
            x: 0.,
            y: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pos2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pos2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pos2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pos2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Rect)
pub struct Rect {
    // message fields
    // @@protoc_insertion_point(field:proto.Rect.min)
    pub min: ::protobuf::MessageField<Pos2>,
    // @@protoc_insertion_point(field:proto.Rect.max)
    pub max: ::protobuf::MessageField<Pos2>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Rect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rect {
    fn default() -> &'a Rect {
        <Rect as ::protobuf::Message>::default_instance()
    }
}

impl Rect {
    pub fn new() -> Rect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pos2>(
            "min",
            |m: &Rect| { &m.min },
            |m: &mut Rect| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pos2>(
            "max",
            |m: &Rect| { &m.max },
            |m: &mut Rect| { &mut m.max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rect>(
            "Rect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rect {
    const NAME: &'static str = "Rect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.min.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.min.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.max.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rect {
        Rect::new()
    }

    fn clear(&mut self) {
        self.min.clear();
        self.max.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rect {
        static instance: Rect = Rect {
            min: ::protobuf::MessageField::none(),
            max: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Modifiers)
pub struct Modifiers {
    // message fields
    // @@protoc_insertion_point(field:proto.Modifiers.alt)
    pub alt: bool,
    // @@protoc_insertion_point(field:proto.Modifiers.ctrl)
    pub ctrl: bool,
    // @@protoc_insertion_point(field:proto.Modifiers.shift)
    pub shift: bool,
    // @@protoc_insertion_point(field:proto.Modifiers.mac_cmd)
    pub mac_cmd: bool,
    // @@protoc_insertion_point(field:proto.Modifiers.command)
    pub command: bool,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Modifiers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Modifiers {
    fn default() -> &'a Modifiers {
        <Modifiers as ::protobuf::Message>::default_instance()
    }
}

impl Modifiers {
    pub fn new() -> Modifiers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alt",
            |m: &Modifiers| { &m.alt },
            |m: &mut Modifiers| { &mut m.alt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ctrl",
            |m: &Modifiers| { &m.ctrl },
            |m: &mut Modifiers| { &mut m.ctrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shift",
            |m: &Modifiers| { &m.shift },
            |m: &mut Modifiers| { &mut m.shift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mac_cmd",
            |m: &Modifiers| { &m.mac_cmd },
            |m: &mut Modifiers| { &mut m.mac_cmd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &Modifiers| { &m.command },
            |m: &mut Modifiers| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Modifiers>(
            "Modifiers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Modifiers {
    const NAME: &'static str = "Modifiers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.alt = is.read_bool()?;
                },
                16 => {
                    self.ctrl = is.read_bool()?;
                },
                24 => {
                    self.shift = is.read_bool()?;
                },
                32 => {
                    self.mac_cmd = is.read_bool()?;
                },
                40 => {
                    self.command = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.alt != false {
            my_size += 1 + 1;
        }
        if self.ctrl != false {
            my_size += 1 + 1;
        }
        if self.shift != false {
            my_size += 1 + 1;
        }
        if self.mac_cmd != false {
            my_size += 1 + 1;
        }
        if self.command != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.alt != false {
            os.write_bool(1, self.alt)?;
        }
        if self.ctrl != false {
            os.write_bool(2, self.ctrl)?;
        }
        if self.shift != false {
            os.write_bool(3, self.shift)?;
        }
        if self.mac_cmd != false {
            os.write_bool(4, self.mac_cmd)?;
        }
        if self.command != false {
            os.write_bool(5, self.command)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Modifiers {
        Modifiers::new()
    }

    fn clear(&mut self) {
        self.alt = false;
        self.ctrl = false;
        self.shift = false;
        self.mac_cmd = false;
        self.command = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Modifiers {
        static instance: Modifiers = Modifiers {
            alt: false,
            ctrl: false,
            shift: false,
            mac_cmd: false,
            command: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Modifiers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Modifiers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Modifiers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Modifiers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Key)
pub struct Key {
    // message fields
    // @@protoc_insertion_point(field:proto.Key.key)
    pub key: ::protobuf::EnumOrUnknown<KeyType>,
    // @@protoc_insertion_point(field:proto.Key.pressed)
    pub pressed: bool,
    // @@protoc_insertion_point(field:proto.Key.modifiers)
    pub modifiers: ::protobuf::MessageField<Modifiers>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Key.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Key| { &m.key },
            |m: &mut Key| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pressed",
            |m: &Key| { &m.pressed },
            |m: &mut Key| { &mut m.pressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Modifiers>(
            "modifiers",
            |m: &Key| { &m.modifiers },
            |m: &mut Key| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key>(
            "Key",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Key {
    const NAME: &'static str = "Key";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.key = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.pressed = is.read_bool()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modifiers)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != ::protobuf::EnumOrUnknown::new(KeyType::KT_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.key.value());
        }
        if self.pressed != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.modifiers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != ::protobuf::EnumOrUnknown::new(KeyType::KT_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.key))?;
        }
        if self.pressed != false {
            os.write_bool(2, self.pressed)?;
        }
        if let Some(v) = self.modifiers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Key {
        Key::new()
    }

    fn clear(&mut self) {
        self.key = ::protobuf::EnumOrUnknown::new(KeyType::KT_NONE);
        self.pressed = false;
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Key {
        static instance: Key = Key {
            key: ::protobuf::EnumOrUnknown::from_i32(0),
            pressed: false,
            modifiers: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Key {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Key").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PointerButton)
pub struct PointerButton {
    // message fields
    // @@protoc_insertion_point(field:proto.PointerButton.pos)
    pub pos: ::protobuf::MessageField<Pos2>,
    // @@protoc_insertion_point(field:proto.PointerButton.button)
    pub button: ::protobuf::EnumOrUnknown<ButtonType>,
    // @@protoc_insertion_point(field:proto.PointerButton.pressed)
    pub pressed: bool,
    // @@protoc_insertion_point(field:proto.PointerButton.modifiers)
    pub modifiers: ::protobuf::MessageField<Modifiers>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PointerButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PointerButton {
    fn default() -> &'a PointerButton {
        <PointerButton as ::protobuf::Message>::default_instance()
    }
}

impl PointerButton {
    pub fn new() -> PointerButton {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pos2>(
            "pos",
            |m: &PointerButton| { &m.pos },
            |m: &mut PointerButton| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "button",
            |m: &PointerButton| { &m.button },
            |m: &mut PointerButton| { &mut m.button },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pressed",
            |m: &PointerButton| { &m.pressed },
            |m: &mut PointerButton| { &mut m.pressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Modifiers>(
            "modifiers",
            |m: &PointerButton| { &m.modifiers },
            |m: &mut PointerButton| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PointerButton>(
            "PointerButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PointerButton {
    const NAME: &'static str = "PointerButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                16 => {
                    self.button = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.pressed = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modifiers)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.button != ::protobuf::EnumOrUnknown::new(ButtonType::BT_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.button.value());
        }
        if self.pressed != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.modifiers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.button != ::protobuf::EnumOrUnknown::new(ButtonType::BT_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.button))?;
        }
        if self.pressed != false {
            os.write_bool(3, self.pressed)?;
        }
        if let Some(v) = self.modifiers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PointerButton {
        PointerButton::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.button = ::protobuf::EnumOrUnknown::new(ButtonType::BT_NONE);
        self.pressed = false;
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PointerButton {
        static instance: PointerButton = PointerButton {
            pos: ::protobuf::MessageField::none(),
            button: ::protobuf::EnumOrUnknown::from_i32(0),
            pressed: false,
            modifiers: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PointerButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PointerButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PointerButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PointerButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Touch)
pub struct Touch {
    // message fields
    // @@protoc_insertion_point(field:proto.Touch.device_id)
    pub device_id: u64,
    // @@protoc_insertion_point(field:proto.Touch.id)
    pub id: u64,
    // @@protoc_insertion_point(field:proto.Touch.phase)
    pub phase: ::protobuf::EnumOrUnknown<TouchPhase>,
    // @@protoc_insertion_point(field:proto.Touch.pos)
    pub pos: ::protobuf::MessageField<Pos2>,
    // @@protoc_insertion_point(field:proto.Touch.force)
    pub force: f32,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Touch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Touch {
    fn default() -> &'a Touch {
        <Touch as ::protobuf::Message>::default_instance()
    }
}

impl Touch {
    pub fn new() -> Touch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &Touch| { &m.device_id },
            |m: &mut Touch| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Touch| { &m.id },
            |m: &mut Touch| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phase",
            |m: &Touch| { &m.phase },
            |m: &mut Touch| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pos2>(
            "pos",
            |m: &Touch| { &m.pos },
            |m: &mut Touch| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "force",
            |m: &Touch| { &m.force },
            |m: &mut Touch| { &mut m.force },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Touch>(
            "Touch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Touch {
    const NAME: &'static str = "Touch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device_id = is.read_uint64()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                24 => {
                    self.phase = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                45 => {
                    self.force = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.device_id);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        if self.phase != ::protobuf::EnumOrUnknown::new(TouchPhase::TP_NONE) {
            my_size += ::protobuf::rt::int32_size(3, self.phase.value());
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.force != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.device_id != 0 {
            os.write_uint64(1, self.device_id)?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        if self.phase != ::protobuf::EnumOrUnknown::new(TouchPhase::TP_NONE) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.phase))?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.force != 0. {
            os.write_float(5, self.force)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Touch {
        Touch::new()
    }

    fn clear(&mut self) {
        self.device_id = 0;
        self.id = 0;
        self.phase = ::protobuf::EnumOrUnknown::new(TouchPhase::TP_NONE);
        self.pos.clear();
        self.force = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Touch {
        static instance: Touch = Touch {
            device_id: 0,
            id: 0,
            phase: ::protobuf::EnumOrUnknown::from_i32(0),
            pos: ::protobuf::MessageField::none(),
            force: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Touch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Touch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Touch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Touch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:proto.Event.et)
    pub et: ::protobuf::EnumOrUnknown<EventType>,
    // @@protoc_insertion_point(field:proto.Event.copy)
    pub copy: bool,
    // @@protoc_insertion_point(field:proto.Event.cut)
    pub cut: bool,
    // @@protoc_insertion_point(field:proto.Event.paste)
    pub paste: ::std::string::String,
    // @@protoc_insertion_point(field:proto.Event.text)
    pub text: ::std::string::String,
    // @@protoc_insertion_point(field:proto.Event.key)
    pub key: ::protobuf::MessageField<Key>,
    // @@protoc_insertion_point(field:proto.Event.pointer_moved)
    pub pointer_moved: ::protobuf::MessageField<Pos2>,
    // @@protoc_insertion_point(field:proto.Event.pointer_button)
    pub pointer_button: ::protobuf::MessageField<PointerButton>,
    // @@protoc_insertion_point(field:proto.Event.pointer_gone)
    pub pointer_gone: bool,
    // @@protoc_insertion_point(field:proto.Event.scroll)
    pub scroll: ::protobuf::MessageField<Pos2>,
    // @@protoc_insertion_point(field:proto.Event.zoom)
    pub zoom: f32,
    // @@protoc_insertion_point(field:proto.Event.composition_start)
    pub composition_start: bool,
    // @@protoc_insertion_point(field:proto.Event.composition_update)
    pub composition_update: ::std::string::String,
    // @@protoc_insertion_point(field:proto.Event.touch)
    pub touch: ::protobuf::MessageField<Touch>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "et",
            |m: &Event| { &m.et },
            |m: &mut Event| { &mut m.et },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy",
            |m: &Event| { &m.copy },
            |m: &mut Event| { &mut m.copy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cut",
            |m: &Event| { &m.cut },
            |m: &mut Event| { &mut m.cut },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paste",
            |m: &Event| { &m.paste },
            |m: &mut Event| { &mut m.paste },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &Event| { &m.text },
            |m: &mut Event| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Key>(
            "key",
            |m: &Event| { &m.key },
            |m: &mut Event| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pos2>(
            "pointer_moved",
            |m: &Event| { &m.pointer_moved },
            |m: &mut Event| { &mut m.pointer_moved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PointerButton>(
            "pointer_button",
            |m: &Event| { &m.pointer_button },
            |m: &mut Event| { &mut m.pointer_button },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pointer_gone",
            |m: &Event| { &m.pointer_gone },
            |m: &mut Event| { &mut m.pointer_gone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pos2>(
            "scroll",
            |m: &Event| { &m.scroll },
            |m: &mut Event| { &mut m.scroll },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zoom",
            |m: &Event| { &m.zoom },
            |m: &mut Event| { &mut m.zoom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "composition_start",
            |m: &Event| { &m.composition_start },
            |m: &mut Event| { &mut m.composition_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "composition_update",
            |m: &Event| { &m.composition_update },
            |m: &mut Event| { &mut m.composition_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Touch>(
            "touch",
            |m: &Event| { &m.touch },
            |m: &mut Event| { &mut m.touch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.et = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.copy = is.read_bool()?;
                },
                24 => {
                    self.cut = is.read_bool()?;
                },
                34 => {
                    self.paste = is.read_string()?;
                },
                42 => {
                    self.text = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pointer_moved)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pointer_button)?;
                },
                72 => {
                    self.pointer_gone = is.read_bool()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll)?;
                },
                93 => {
                    self.zoom = is.read_float()?;
                },
                96 => {
                    self.composition_start = is.read_bool()?;
                },
                106 => {
                    self.composition_update = is.read_string()?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.touch)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.et != ::protobuf::EnumOrUnknown::new(EventType::ET_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.et.value());
        }
        if self.copy != false {
            my_size += 1 + 1;
        }
        if self.cut != false {
            my_size += 1 + 1;
        }
        if !self.paste.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.paste);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.text);
        }
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pointer_moved.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pointer_button.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.pointer_gone != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.scroll.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.zoom != 0. {
            my_size += 1 + 4;
        }
        if self.composition_start != false {
            my_size += 1 + 1;
        }
        if !self.composition_update.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.composition_update);
        }
        if let Some(v) = self.touch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.et != ::protobuf::EnumOrUnknown::new(EventType::ET_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.et))?;
        }
        if self.copy != false {
            os.write_bool(2, self.copy)?;
        }
        if self.cut != false {
            os.write_bool(3, self.cut)?;
        }
        if !self.paste.is_empty() {
            os.write_string(4, &self.paste)?;
        }
        if !self.text.is_empty() {
            os.write_string(5, &self.text)?;
        }
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.pointer_moved.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.pointer_button.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.pointer_gone != false {
            os.write_bool(9, self.pointer_gone)?;
        }
        if let Some(v) = self.scroll.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.zoom != 0. {
            os.write_float(11, self.zoom)?;
        }
        if self.composition_start != false {
            os.write_bool(12, self.composition_start)?;
        }
        if !self.composition_update.is_empty() {
            os.write_string(13, &self.composition_update)?;
        }
        if let Some(v) = self.touch.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.et = ::protobuf::EnumOrUnknown::new(EventType::ET_NONE);
        self.copy = false;
        self.cut = false;
        self.paste.clear();
        self.text.clear();
        self.key.clear();
        self.pointer_moved.clear();
        self.pointer_button.clear();
        self.pointer_gone = false;
        self.scroll.clear();
        self.zoom = 0.;
        self.composition_start = false;
        self.composition_update.clear();
        self.touch.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            et: ::protobuf::EnumOrUnknown::from_i32(0),
            copy: false,
            cut: false,
            paste: ::std::string::String::new(),
            text: ::std::string::String::new(),
            key: ::protobuf::MessageField::none(),
            pointer_moved: ::protobuf::MessageField::none(),
            pointer_button: ::protobuf::MessageField::none(),
            pointer_gone: false,
            scroll: ::protobuf::MessageField::none(),
            zoom: 0.,
            composition_start: false,
            composition_update: ::std::string::String::new(),
            touch: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Input)
pub struct Input {
    // message fields
    // @@protoc_insertion_point(field:proto.Input.screen_rect)
    pub screen_rect: ::protobuf::MessageField<Rect>,
    // @@protoc_insertion_point(field:proto.Input.pixels_per_point)
    pub pixels_per_point: f32,
    // @@protoc_insertion_point(field:proto.Input.max_texture_side)
    pub max_texture_side: u32,
    // @@protoc_insertion_point(field:proto.Input.time)
    pub time: u32,
    // @@protoc_insertion_point(field:proto.Input.predicted_dt)
    pub predicted_dt: f32,
    // @@protoc_insertion_point(field:proto.Input.events)
    pub events: ::std::vec::Vec<Event>,
    // @@protoc_insertion_point(field:proto.Input.has_focus)
    pub has_focus: bool,
    // @@protoc_insertion_point(field:proto.Input.modifier)
    pub modifier: ::protobuf::MessageField<Modifiers>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Input.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Input {
    fn default() -> &'a Input {
        <Input as ::protobuf::Message>::default_instance()
    }
}

impl Input {
    pub fn new() -> Input {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rect>(
            "screen_rect",
            |m: &Input| { &m.screen_rect },
            |m: &mut Input| { &mut m.screen_rect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pixels_per_point",
            |m: &Input| { &m.pixels_per_point },
            |m: &mut Input| { &mut m.pixels_per_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_texture_side",
            |m: &Input| { &m.max_texture_side },
            |m: &mut Input| { &mut m.max_texture_side },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &Input| { &m.time },
            |m: &mut Input| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "predicted_dt",
            |m: &Input| { &m.predicted_dt },
            |m: &mut Input| { &mut m.predicted_dt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &Input| { &m.events },
            |m: &mut Input| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_focus",
            |m: &Input| { &m.has_focus },
            |m: &mut Input| { &mut m.has_focus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Modifiers>(
            "modifier",
            |m: &Input| { &m.modifier },
            |m: &mut Input| { &mut m.modifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Input>(
            "Input",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Input {
    const NAME: &'static str = "Input";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.screen_rect)?;
                },
                21 => {
                    self.pixels_per_point = is.read_float()?;
                },
                24 => {
                    self.max_texture_side = is.read_uint32()?;
                },
                32 => {
                    self.time = is.read_uint32()?;
                },
                45 => {
                    self.predicted_dt = is.read_float()?;
                },
                50 => {
                    self.events.push(is.read_message()?);
                },
                56 => {
                    self.has_focus = is.read_bool()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modifier)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screen_rect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.pixels_per_point != 0. {
            my_size += 1 + 4;
        }
        if self.max_texture_side != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.max_texture_side);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.time);
        }
        if self.predicted_dt != 0. {
            my_size += 1 + 4;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.has_focus != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.modifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screen_rect.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.pixels_per_point != 0. {
            os.write_float(2, self.pixels_per_point)?;
        }
        if self.max_texture_side != 0 {
            os.write_uint32(3, self.max_texture_side)?;
        }
        if self.time != 0 {
            os.write_uint32(4, self.time)?;
        }
        if self.predicted_dt != 0. {
            os.write_float(5, self.predicted_dt)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.has_focus != false {
            os.write_bool(7, self.has_focus)?;
        }
        if let Some(v) = self.modifier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Input {
        Input::new()
    }

    fn clear(&mut self) {
        self.screen_rect.clear();
        self.pixels_per_point = 0.;
        self.max_texture_side = 0;
        self.time = 0;
        self.predicted_dt = 0.;
        self.events.clear();
        self.has_focus = false;
        self.modifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Input {
        static instance: Input = Input {
            screen_rect: ::protobuf::MessageField::none(),
            pixels_per_point: 0.,
            max_texture_side: 0,
            time: 0,
            predicted_dt: 0.,
            events: ::std::vec::Vec::new(),
            has_focus: false,
            modifier: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Input {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Input").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Input {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.KeyType)
pub enum KeyType {
    // @@protoc_insertion_point(enum_value:proto.KeyType.KT_NONE)
    KT_NONE = 0,
    // @@protoc_insertion_point(enum_value:proto.KeyType.ArrowDown)
    ArrowDown = 1,
    // @@protoc_insertion_point(enum_value:proto.KeyType.ArrowLeft)
    ArrowLeft = 2,
    // @@protoc_insertion_point(enum_value:proto.KeyType.ArrowRight)
    ArrowRight = 3,
    // @@protoc_insertion_point(enum_value:proto.KeyType.ArrowUp)
    ArrowUp = 4,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Escape)
    Escape = 5,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Tab)
    Tab = 6,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Backspace)
    Backspace = 7,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Enter)
    Enter = 8,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Space)
    Space = 9,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Insert)
    Insert = 10,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Delete)
    Delete = 11,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Home)
    Home = 12,
    // @@protoc_insertion_point(enum_value:proto.KeyType.End)
    End = 13,
    // @@protoc_insertion_point(enum_value:proto.KeyType.PageUp)
    PageUp = 14,
    // @@protoc_insertion_point(enum_value:proto.KeyType.PageDown)
    PageDown = 15,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num0)
    Num0 = 16,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num1)
    Num1 = 17,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num2)
    Num2 = 18,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num3)
    Num3 = 19,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num4)
    Num4 = 20,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num5)
    Num5 = 21,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num6)
    Num6 = 22,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num7)
    Num7 = 23,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num8)
    Num8 = 24,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Num9)
    Num9 = 25,
    // @@protoc_insertion_point(enum_value:proto.KeyType.A)
    A = 26,
    // @@protoc_insertion_point(enum_value:proto.KeyType.B)
    B = 27,
    // @@protoc_insertion_point(enum_value:proto.KeyType.C)
    C = 28,
    // @@protoc_insertion_point(enum_value:proto.KeyType.D)
    D = 29,
    // @@protoc_insertion_point(enum_value:proto.KeyType.E)
    E = 30,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F)
    F = 31,
    // @@protoc_insertion_point(enum_value:proto.KeyType.G)
    G = 32,
    // @@protoc_insertion_point(enum_value:proto.KeyType.H)
    H = 33,
    // @@protoc_insertion_point(enum_value:proto.KeyType.I)
    I = 34,
    // @@protoc_insertion_point(enum_value:proto.KeyType.J)
    J = 35,
    // @@protoc_insertion_point(enum_value:proto.KeyType.K)
    K = 37,
    // @@protoc_insertion_point(enum_value:proto.KeyType.L)
    L = 38,
    // @@protoc_insertion_point(enum_value:proto.KeyType.M)
    M = 39,
    // @@protoc_insertion_point(enum_value:proto.KeyType.N)
    N = 40,
    // @@protoc_insertion_point(enum_value:proto.KeyType.O)
    O = 41,
    // @@protoc_insertion_point(enum_value:proto.KeyType.P)
    P = 42,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Q)
    Q = 43,
    // @@protoc_insertion_point(enum_value:proto.KeyType.R)
    R = 44,
    // @@protoc_insertion_point(enum_value:proto.KeyType.S)
    S = 45,
    // @@protoc_insertion_point(enum_value:proto.KeyType.T)
    T = 46,
    // @@protoc_insertion_point(enum_value:proto.KeyType.U)
    U = 47,
    // @@protoc_insertion_point(enum_value:proto.KeyType.V)
    V = 48,
    // @@protoc_insertion_point(enum_value:proto.KeyType.W)
    W = 49,
    // @@protoc_insertion_point(enum_value:proto.KeyType.X)
    X = 50,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Y)
    Y = 51,
    // @@protoc_insertion_point(enum_value:proto.KeyType.Z)
    Z = 52,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F1)
    F1 = 53,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F2)
    F2 = 54,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F3)
    F3 = 55,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F4)
    F4 = 56,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F5)
    F5 = 57,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F6)
    F6 = 58,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F7)
    F7 = 59,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F8)
    F8 = 60,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F9)
    F9 = 61,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F10)
    F10 = 62,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F11)
    F11 = 63,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F12)
    F12 = 64,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F13)
    F13 = 65,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F14)
    F14 = 66,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F15)
    F15 = 67,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F16)
    F16 = 68,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F17)
    F17 = 69,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F18)
    F18 = 70,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F19)
    F19 = 71,
    // @@protoc_insertion_point(enum_value:proto.KeyType.F20)
    F20 = 72,
}

impl ::protobuf::Enum for KeyType {
    const NAME: &'static str = "KeyType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyType> {
        match value {
            0 => ::std::option::Option::Some(KeyType::KT_NONE),
            1 => ::std::option::Option::Some(KeyType::ArrowDown),
            2 => ::std::option::Option::Some(KeyType::ArrowLeft),
            3 => ::std::option::Option::Some(KeyType::ArrowRight),
            4 => ::std::option::Option::Some(KeyType::ArrowUp),
            5 => ::std::option::Option::Some(KeyType::Escape),
            6 => ::std::option::Option::Some(KeyType::Tab),
            7 => ::std::option::Option::Some(KeyType::Backspace),
            8 => ::std::option::Option::Some(KeyType::Enter),
            9 => ::std::option::Option::Some(KeyType::Space),
            10 => ::std::option::Option::Some(KeyType::Insert),
            11 => ::std::option::Option::Some(KeyType::Delete),
            12 => ::std::option::Option::Some(KeyType::Home),
            13 => ::std::option::Option::Some(KeyType::End),
            14 => ::std::option::Option::Some(KeyType::PageUp),
            15 => ::std::option::Option::Some(KeyType::PageDown),
            16 => ::std::option::Option::Some(KeyType::Num0),
            17 => ::std::option::Option::Some(KeyType::Num1),
            18 => ::std::option::Option::Some(KeyType::Num2),
            19 => ::std::option::Option::Some(KeyType::Num3),
            20 => ::std::option::Option::Some(KeyType::Num4),
            21 => ::std::option::Option::Some(KeyType::Num5),
            22 => ::std::option::Option::Some(KeyType::Num6),
            23 => ::std::option::Option::Some(KeyType::Num7),
            24 => ::std::option::Option::Some(KeyType::Num8),
            25 => ::std::option::Option::Some(KeyType::Num9),
            26 => ::std::option::Option::Some(KeyType::A),
            27 => ::std::option::Option::Some(KeyType::B),
            28 => ::std::option::Option::Some(KeyType::C),
            29 => ::std::option::Option::Some(KeyType::D),
            30 => ::std::option::Option::Some(KeyType::E),
            31 => ::std::option::Option::Some(KeyType::F),
            32 => ::std::option::Option::Some(KeyType::G),
            33 => ::std::option::Option::Some(KeyType::H),
            34 => ::std::option::Option::Some(KeyType::I),
            35 => ::std::option::Option::Some(KeyType::J),
            37 => ::std::option::Option::Some(KeyType::K),
            38 => ::std::option::Option::Some(KeyType::L),
            39 => ::std::option::Option::Some(KeyType::M),
            40 => ::std::option::Option::Some(KeyType::N),
            41 => ::std::option::Option::Some(KeyType::O),
            42 => ::std::option::Option::Some(KeyType::P),
            43 => ::std::option::Option::Some(KeyType::Q),
            44 => ::std::option::Option::Some(KeyType::R),
            45 => ::std::option::Option::Some(KeyType::S),
            46 => ::std::option::Option::Some(KeyType::T),
            47 => ::std::option::Option::Some(KeyType::U),
            48 => ::std::option::Option::Some(KeyType::V),
            49 => ::std::option::Option::Some(KeyType::W),
            50 => ::std::option::Option::Some(KeyType::X),
            51 => ::std::option::Option::Some(KeyType::Y),
            52 => ::std::option::Option::Some(KeyType::Z),
            53 => ::std::option::Option::Some(KeyType::F1),
            54 => ::std::option::Option::Some(KeyType::F2),
            55 => ::std::option::Option::Some(KeyType::F3),
            56 => ::std::option::Option::Some(KeyType::F4),
            57 => ::std::option::Option::Some(KeyType::F5),
            58 => ::std::option::Option::Some(KeyType::F6),
            59 => ::std::option::Option::Some(KeyType::F7),
            60 => ::std::option::Option::Some(KeyType::F8),
            61 => ::std::option::Option::Some(KeyType::F9),
            62 => ::std::option::Option::Some(KeyType::F10),
            63 => ::std::option::Option::Some(KeyType::F11),
            64 => ::std::option::Option::Some(KeyType::F12),
            65 => ::std::option::Option::Some(KeyType::F13),
            66 => ::std::option::Option::Some(KeyType::F14),
            67 => ::std::option::Option::Some(KeyType::F15),
            68 => ::std::option::Option::Some(KeyType::F16),
            69 => ::std::option::Option::Some(KeyType::F17),
            70 => ::std::option::Option::Some(KeyType::F18),
            71 => ::std::option::Option::Some(KeyType::F19),
            72 => ::std::option::Option::Some(KeyType::F20),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyType] = &[
        KeyType::KT_NONE,
        KeyType::ArrowDown,
        KeyType::ArrowLeft,
        KeyType::ArrowRight,
        KeyType::ArrowUp,
        KeyType::Escape,
        KeyType::Tab,
        KeyType::Backspace,
        KeyType::Enter,
        KeyType::Space,
        KeyType::Insert,
        KeyType::Delete,
        KeyType::Home,
        KeyType::End,
        KeyType::PageUp,
        KeyType::PageDown,
        KeyType::Num0,
        KeyType::Num1,
        KeyType::Num2,
        KeyType::Num3,
        KeyType::Num4,
        KeyType::Num5,
        KeyType::Num6,
        KeyType::Num7,
        KeyType::Num8,
        KeyType::Num9,
        KeyType::A,
        KeyType::B,
        KeyType::C,
        KeyType::D,
        KeyType::E,
        KeyType::F,
        KeyType::G,
        KeyType::H,
        KeyType::I,
        KeyType::J,
        KeyType::K,
        KeyType::L,
        KeyType::M,
        KeyType::N,
        KeyType::O,
        KeyType::P,
        KeyType::Q,
        KeyType::R,
        KeyType::S,
        KeyType::T,
        KeyType::U,
        KeyType::V,
        KeyType::W,
        KeyType::X,
        KeyType::Y,
        KeyType::Z,
        KeyType::F1,
        KeyType::F2,
        KeyType::F3,
        KeyType::F4,
        KeyType::F5,
        KeyType::F6,
        KeyType::F7,
        KeyType::F8,
        KeyType::F9,
        KeyType::F10,
        KeyType::F11,
        KeyType::F12,
        KeyType::F13,
        KeyType::F14,
        KeyType::F15,
        KeyType::F16,
        KeyType::F17,
        KeyType::F18,
        KeyType::F19,
        KeyType::F20,
    ];
}

impl ::protobuf::EnumFull for KeyType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            KeyType::KT_NONE => 0,
            KeyType::ArrowDown => 1,
            KeyType::ArrowLeft => 2,
            KeyType::ArrowRight => 3,
            KeyType::ArrowUp => 4,
            KeyType::Escape => 5,
            KeyType::Tab => 6,
            KeyType::Backspace => 7,
            KeyType::Enter => 8,
            KeyType::Space => 9,
            KeyType::Insert => 10,
            KeyType::Delete => 11,
            KeyType::Home => 12,
            KeyType::End => 13,
            KeyType::PageUp => 14,
            KeyType::PageDown => 15,
            KeyType::Num0 => 16,
            KeyType::Num1 => 17,
            KeyType::Num2 => 18,
            KeyType::Num3 => 19,
            KeyType::Num4 => 20,
            KeyType::Num5 => 21,
            KeyType::Num6 => 22,
            KeyType::Num7 => 23,
            KeyType::Num8 => 24,
            KeyType::Num9 => 25,
            KeyType::A => 26,
            KeyType::B => 27,
            KeyType::C => 28,
            KeyType::D => 29,
            KeyType::E => 30,
            KeyType::F => 31,
            KeyType::G => 32,
            KeyType::H => 33,
            KeyType::I => 34,
            KeyType::J => 35,
            KeyType::K => 36,
            KeyType::L => 37,
            KeyType::M => 38,
            KeyType::N => 39,
            KeyType::O => 40,
            KeyType::P => 41,
            KeyType::Q => 42,
            KeyType::R => 43,
            KeyType::S => 44,
            KeyType::T => 45,
            KeyType::U => 46,
            KeyType::V => 47,
            KeyType::W => 48,
            KeyType::X => 49,
            KeyType::Y => 50,
            KeyType::Z => 51,
            KeyType::F1 => 52,
            KeyType::F2 => 53,
            KeyType::F3 => 54,
            KeyType::F4 => 55,
            KeyType::F5 => 56,
            KeyType::F6 => 57,
            KeyType::F7 => 58,
            KeyType::F8 => 59,
            KeyType::F9 => 60,
            KeyType::F10 => 61,
            KeyType::F11 => 62,
            KeyType::F12 => 63,
            KeyType::F13 => 64,
            KeyType::F14 => 65,
            KeyType::F15 => 66,
            KeyType::F16 => 67,
            KeyType::F17 => 68,
            KeyType::F18 => 69,
            KeyType::F19 => 70,
            KeyType::F20 => 71,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KeyType {
    fn default() -> Self {
        KeyType::KT_NONE
    }
}

impl KeyType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyType>("KeyType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.ButtonType)
pub enum ButtonType {
    // @@protoc_insertion_point(enum_value:proto.ButtonType.BT_NONE)
    BT_NONE = 0,
    // @@protoc_insertion_point(enum_value:proto.ButtonType.PRIMARY)
    PRIMARY = 1,
    // @@protoc_insertion_point(enum_value:proto.ButtonType.SECONDARY)
    SECONDARY = 2,
    // @@protoc_insertion_point(enum_value:proto.ButtonType.MIDDLE)
    MIDDLE = 3,
    // @@protoc_insertion_point(enum_value:proto.ButtonType.EXTRA1)
    EXTRA1 = 4,
    // @@protoc_insertion_point(enum_value:proto.ButtonType.EXTRA2)
    EXTRA2 = 5,
}

impl ::protobuf::Enum for ButtonType {
    const NAME: &'static str = "ButtonType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ButtonType> {
        match value {
            0 => ::std::option::Option::Some(ButtonType::BT_NONE),
            1 => ::std::option::Option::Some(ButtonType::PRIMARY),
            2 => ::std::option::Option::Some(ButtonType::SECONDARY),
            3 => ::std::option::Option::Some(ButtonType::MIDDLE),
            4 => ::std::option::Option::Some(ButtonType::EXTRA1),
            5 => ::std::option::Option::Some(ButtonType::EXTRA2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ButtonType] = &[
        ButtonType::BT_NONE,
        ButtonType::PRIMARY,
        ButtonType::SECONDARY,
        ButtonType::MIDDLE,
        ButtonType::EXTRA1,
        ButtonType::EXTRA2,
    ];
}

impl ::protobuf::EnumFull for ButtonType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ButtonType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ButtonType {
    fn default() -> Self {
        ButtonType::BT_NONE
    }
}

impl ButtonType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ButtonType>("ButtonType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.TouchPhase)
pub enum TouchPhase {
    // @@protoc_insertion_point(enum_value:proto.TouchPhase.TP_NONE)
    TP_NONE = 0,
    // @@protoc_insertion_point(enum_value:proto.TouchPhase.START)
    START = 1,
    // @@protoc_insertion_point(enum_value:proto.TouchPhase.MOVE)
    MOVE = 2,
    // @@protoc_insertion_point(enum_value:proto.TouchPhase.END)
    END = 3,
    // @@protoc_insertion_point(enum_value:proto.TouchPhase.CANCEL)
    CANCEL = 4,
}

impl ::protobuf::Enum for TouchPhase {
    const NAME: &'static str = "TouchPhase";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TouchPhase> {
        match value {
            0 => ::std::option::Option::Some(TouchPhase::TP_NONE),
            1 => ::std::option::Option::Some(TouchPhase::START),
            2 => ::std::option::Option::Some(TouchPhase::MOVE),
            3 => ::std::option::Option::Some(TouchPhase::END),
            4 => ::std::option::Option::Some(TouchPhase::CANCEL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TouchPhase] = &[
        TouchPhase::TP_NONE,
        TouchPhase::START,
        TouchPhase::MOVE,
        TouchPhase::END,
        TouchPhase::CANCEL,
    ];
}

impl ::protobuf::EnumFull for TouchPhase {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TouchPhase").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TouchPhase {
    fn default() -> Self {
        TouchPhase::TP_NONE
    }
}

impl TouchPhase {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TouchPhase>("TouchPhase")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.EventType)
pub enum EventType {
    // @@protoc_insertion_point(enum_value:proto.EventType.ET_NONE)
    ET_NONE = 0,
    // @@protoc_insertion_point(enum_value:proto.EventType.COPY)
    COPY = 2,
    // @@protoc_insertion_point(enum_value:proto.EventType.CUT)
    CUT = 3,
    // @@protoc_insertion_point(enum_value:proto.EventType.PASTE)
    PASTE = 4,
    // @@protoc_insertion_point(enum_value:proto.EventType.TEXT)
    TEXT = 5,
    // @@protoc_insertion_point(enum_value:proto.EventType.KEY)
    KEY = 6,
    // @@protoc_insertion_point(enum_value:proto.EventType.POINTER_MOVED)
    POINTER_MOVED = 7,
    // @@protoc_insertion_point(enum_value:proto.EventType.POINTER_BUTTON)
    POINTER_BUTTON = 8,
    // @@protoc_insertion_point(enum_value:proto.EventType.POINTER_GONE)
    POINTER_GONE = 9,
    // @@protoc_insertion_point(enum_value:proto.EventType.SCROLL)
    SCROLL = 10,
    // @@protoc_insertion_point(enum_value:proto.EventType.ZOOM)
    ZOOM = 11,
    // @@protoc_insertion_point(enum_value:proto.EventType.COMPOSITION_START)
    COMPOSITION_START = 12,
    // @@protoc_insertion_point(enum_value:proto.EventType.COMPOSITION_UPDATE)
    COMPOSITION_UPDATE = 13,
    // @@protoc_insertion_point(enum_value:proto.EventType.TOUCH)
    TOUCH = 14,
}

impl ::protobuf::Enum for EventType {
    const NAME: &'static str = "EventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventType> {
        match value {
            0 => ::std::option::Option::Some(EventType::ET_NONE),
            2 => ::std::option::Option::Some(EventType::COPY),
            3 => ::std::option::Option::Some(EventType::CUT),
            4 => ::std::option::Option::Some(EventType::PASTE),
            5 => ::std::option::Option::Some(EventType::TEXT),
            6 => ::std::option::Option::Some(EventType::KEY),
            7 => ::std::option::Option::Some(EventType::POINTER_MOVED),
            8 => ::std::option::Option::Some(EventType::POINTER_BUTTON),
            9 => ::std::option::Option::Some(EventType::POINTER_GONE),
            10 => ::std::option::Option::Some(EventType::SCROLL),
            11 => ::std::option::Option::Some(EventType::ZOOM),
            12 => ::std::option::Option::Some(EventType::COMPOSITION_START),
            13 => ::std::option::Option::Some(EventType::COMPOSITION_UPDATE),
            14 => ::std::option::Option::Some(EventType::TOUCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EventType] = &[
        EventType::ET_NONE,
        EventType::COPY,
        EventType::CUT,
        EventType::PASTE,
        EventType::TEXT,
        EventType::KEY,
        EventType::POINTER_MOVED,
        EventType::POINTER_BUTTON,
        EventType::POINTER_GONE,
        EventType::SCROLL,
        EventType::ZOOM,
        EventType::COMPOSITION_START,
        EventType::COMPOSITION_UPDATE,
        EventType::TOUCH,
    ];
}

impl ::protobuf::EnumFull for EventType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EventType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EventType::ET_NONE => 0,
            EventType::COPY => 1,
            EventType::CUT => 2,
            EventType::PASTE => 3,
            EventType::TEXT => 4,
            EventType::KEY => 5,
            EventType::POINTER_MOVED => 6,
            EventType::POINTER_BUTTON => 7,
            EventType::POINTER_GONE => 8,
            EventType::SCROLL => 9,
            EventType::ZOOM => 10,
            EventType::COMPOSITION_START => 11,
            EventType::COMPOSITION_UPDATE => 12,
            EventType::TOUCH => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EventType {
    fn default() -> Self {
        EventType::ET_NONE
    }
}

impl EventType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EventType>("EventType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0binput.proto\x12\x05proto\"\"\n\x04Pos2\x12\x0c\n\x01x\x18\x01\x20\
    \x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x02R\x01y\"D\n\x04Rect\
    \x12\x1d\n\x03min\x18\x01\x20\x01(\x0b2\x0b.proto.Pos2R\x03min\x12\x1d\n\
    \x03max\x18\x02\x20\x01(\x0b2\x0b.proto.Pos2R\x03max\"z\n\tModifiers\x12\
    \x10\n\x03alt\x18\x01\x20\x01(\x08R\x03alt\x12\x12\n\x04ctrl\x18\x02\x20\
    \x01(\x08R\x04ctrl\x12\x14\n\x05shift\x18\x03\x20\x01(\x08R\x05shift\x12\
    \x17\n\x07mac_cmd\x18\x04\x20\x01(\x08R\x06macCmd\x12\x18\n\x07command\
    \x18\x05\x20\x01(\x08R\x07command\"q\n\x03Key\x12\x20\n\x03key\x18\x01\
    \x20\x01(\x0e2\x0e.proto.KeyTypeR\x03key\x12\x18\n\x07pressed\x18\x02\
    \x20\x01(\x08R\x07pressed\x12.\n\tmodifiers\x18\x03\x20\x01(\x0b2\x10.pr\
    oto.ModifiersR\tmodifiers\"\xa3\x01\n\rPointerButton\x12\x1d\n\x03pos\
    \x18\x01\x20\x01(\x0b2\x0b.proto.Pos2R\x03pos\x12)\n\x06button\x18\x02\
    \x20\x01(\x0e2\x11.proto.ButtonTypeR\x06button\x12\x18\n\x07pressed\x18\
    \x03\x20\x01(\x08R\x07pressed\x12.\n\tmodifiers\x18\x04\x20\x01(\x0b2\
    \x10.proto.ModifiersR\tmodifiers\"\x92\x01\n\x05Touch\x12\x1b\n\tdevice_\
    id\x18\x01\x20\x01(\x04R\x08deviceId\x12\x0e\n\x02id\x18\x02\x20\x01(\
    \x04R\x02id\x12'\n\x05phase\x18\x03\x20\x01(\x0e2\x11.proto.TouchPhaseR\
    \x05phase\x12\x1d\n\x03pos\x18\x04\x20\x01(\x0b2\x0b.proto.Pos2R\x03pos\
    \x12\x14\n\x05force\x18\x05\x20\x01(\x02R\x05force\"\xe2\x03\n\x05Event\
    \x12\x20\n\x02et\x18\x01\x20\x01(\x0e2\x10.proto.EventTypeR\x02et\x12\
    \x12\n\x04copy\x18\x02\x20\x01(\x08R\x04copy\x12\x10\n\x03cut\x18\x03\
    \x20\x01(\x08R\x03cut\x12\x14\n\x05paste\x18\x04\x20\x01(\tR\x05paste\
    \x12\x12\n\x04text\x18\x05\x20\x01(\tR\x04text\x12\x1c\n\x03key\x18\x06\
    \x20\x01(\x0b2\n.proto.KeyR\x03key\x120\n\rpointer_moved\x18\x07\x20\x01\
    (\x0b2\x0b.proto.Pos2R\x0cpointerMoved\x12;\n\x0epointer_button\x18\x08\
    \x20\x01(\x0b2\x14.proto.PointerButtonR\rpointerButton\x12!\n\x0cpointer\
    _gone\x18\t\x20\x01(\x08R\x0bpointerGone\x12#\n\x06scroll\x18\n\x20\x01(\
    \x0b2\x0b.proto.Pos2R\x06scroll\x12\x12\n\x04zoom\x18\x0b\x20\x01(\x02R\
    \x04zoom\x12+\n\x11composition_start\x18\x0c\x20\x01(\x08R\x10compositio\
    nStart\x12-\n\x12composition_update\x18\r\x20\x01(\tR\x11compositionUpda\
    te\x12\"\n\x05touch\x18\x0e\x20\x01(\x0b2\x0c.proto.TouchR\x05touch\"\
    \xb1\x02\n\x05Input\x12,\n\x0bscreen_rect\x18\x01\x20\x01(\x0b2\x0b.prot\
    o.RectR\nscreenRect\x12(\n\x10pixels_per_point\x18\x02\x20\x01(\x02R\x0e\
    pixelsPerPoint\x12(\n\x10max_texture_side\x18\x03\x20\x01(\rR\x0emaxText\
    ureSide\x12\x12\n\x04time\x18\x04\x20\x01(\rR\x04time\x12!\n\x0cpredicte\
    d_dt\x18\x05\x20\x01(\x02R\x0bpredictedDt\x12$\n\x06events\x18\x06\x20\
    \x03(\x0b2\x0c.proto.EventR\x06events\x12\x1b\n\thas_focus\x18\x07\x20\
    \x01(\x08R\x08hasFocus\x12,\n\x08modifier\x18\x08\x20\x01(\x0b2\x10.prot\
    o.ModifiersR\x08modifier*\x95\x05\n\x07KeyType\x12\x0b\n\x07KT_NONE\x10\
    \0\x12\r\n\tArrowDown\x10\x01\x12\r\n\tArrowLeft\x10\x02\x12\x0e\n\nArro\
    wRight\x10\x03\x12\x0b\n\x07ArrowUp\x10\x04\x12\n\n\x06Escape\x10\x05\
    \x12\x07\n\x03Tab\x10\x06\x12\r\n\tBackspace\x10\x07\x12\t\n\x05Enter\
    \x10\x08\x12\t\n\x05Space\x10\t\x12\n\n\x06Insert\x10\n\x12\n\n\x06Delet\
    e\x10\x0b\x12\x08\n\x04Home\x10\x0c\x12\x07\n\x03End\x10\r\x12\n\n\x06Pa\
    geUp\x10\x0e\x12\x0c\n\x08PageDown\x10\x0f\x12\x08\n\x04Num0\x10\x10\x12\
    \x08\n\x04Num1\x10\x11\x12\x08\n\x04Num2\x10\x12\x12\x08\n\x04Num3\x10\
    \x13\x12\x08\n\x04Num4\x10\x14\x12\x08\n\x04Num5\x10\x15\x12\x08\n\x04Nu\
    m6\x10\x16\x12\x08\n\x04Num7\x10\x17\x12\x08\n\x04Num8\x10\x18\x12\x08\n\
    \x04Num9\x10\x19\x12\x05\n\x01A\x10\x1a\x12\x05\n\x01B\x10\x1b\x12\x05\n\
    \x01C\x10\x1c\x12\x05\n\x01D\x10\x1d\x12\x05\n\x01E\x10\x1e\x12\x05\n\
    \x01F\x10\x1f\x12\x05\n\x01G\x10\x20\x12\x05\n\x01H\x10!\x12\x05\n\x01I\
    \x10\"\x12\x05\n\x01J\x10#\x12\x05\n\x01K\x10%\x12\x05\n\x01L\x10&\x12\
    \x05\n\x01M\x10'\x12\x05\n\x01N\x10(\x12\x05\n\x01O\x10)\x12\x05\n\x01P\
    \x10*\x12\x05\n\x01Q\x10+\x12\x05\n\x01R\x10,\x12\x05\n\x01S\x10-\x12\
    \x05\n\x01T\x10.\x12\x05\n\x01U\x10/\x12\x05\n\x01V\x100\x12\x05\n\x01W\
    \x101\x12\x05\n\x01X\x102\x12\x05\n\x01Y\x103\x12\x05\n\x01Z\x104\x12\
    \x06\n\x02F1\x105\x12\x06\n\x02F2\x106\x12\x06\n\x02F3\x107\x12\x06\n\
    \x02F4\x108\x12\x06\n\x02F5\x109\x12\x06\n\x02F6\x10:\x12\x06\n\x02F7\
    \x10;\x12\x06\n\x02F8\x10<\x12\x06\n\x02F9\x10=\x12\x07\n\x03F10\x10>\
    \x12\x07\n\x03F11\x10?\x12\x07\n\x03F12\x10@\x12\x07\n\x03F13\x10A\x12\
    \x07\n\x03F14\x10B\x12\x07\n\x03F15\x10C\x12\x07\n\x03F16\x10D\x12\x07\n\
    \x03F17\x10E\x12\x07\n\x03F18\x10F\x12\x07\n\x03F19\x10G\x12\x07\n\x03F2\
    0\x10H*Y\n\nButtonType\x12\x0b\n\x07BT_NONE\x10\0\x12\x0b\n\x07PRIMARY\
    \x10\x01\x12\r\n\tSECONDARY\x10\x02\x12\n\n\x06MIDDLE\x10\x03\x12\n\n\
    \x06EXTRA1\x10\x04\x12\n\n\x06EXTRA2\x10\x05*C\n\nTouchPhase\x12\x0b\n\
    \x07TP_NONE\x10\0\x12\t\n\x05START\x10\x01\x12\x08\n\x04MOVE\x10\x02\x12\
    \x07\n\x03END\x10\x03\x12\n\n\x06CANCEL\x10\x04*\xd2\x01\n\tEventType\
    \x12\x0b\n\x07ET_NONE\x10\0\x12\x08\n\x04COPY\x10\x02\x12\x07\n\x03CUT\
    \x10\x03\x12\t\n\x05PASTE\x10\x04\x12\x08\n\x04TEXT\x10\x05\x12\x07\n\
    \x03KEY\x10\x06\x12\x11\n\rPOINTER_MOVED\x10\x07\x12\x12\n\x0ePOINTER_BU\
    TTON\x10\x08\x12\x10\n\x0cPOINTER_GONE\x10\t\x12\n\n\x06SCROLL\x10\n\x12\
    \x08\n\x04ZOOM\x10\x0b\x12\x15\n\x11COMPOSITION_START\x10\x0c\x12\x16\n\
    \x12COMPOSITION_UPDATE\x10\r\x12\t\n\x05TOUCH\x10\x0eJ\xab=\n\x07\x12\
    \x05\0\0\xc2\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\
    \x03\x02\0\x0e\n\n\n\x02\x04\0\x12\x04\x04\0\x07\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\x04\x08\x0c\n\x0b\n\x04\x04\0\x02\0\x12\x03\x05\x02\x0e\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03\x05\x02\x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x05\x08\t\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x05\x0c\r\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\x06\x02\x0e\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\
    \x06\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x06\x08\t\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\x06\x0c\r\n\n\n\x02\x04\x01\x12\x04\t\0\x0c\
    \x01\n\n\n\x03\x04\x01\x01\x12\x03\t\x08\x0c\n\x0b\n\x04\x04\x01\x02\0\
    \x12\x03\n\x02\x0f\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\n\x02\x06\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03\n\x07\n\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\n\r\x0e\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x0b\x02\x0f\n\x0c\n\
    \x05\x04\x01\x02\x01\x06\x12\x03\x0b\x02\x06\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03\x0b\x07\n\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x0b\r\x0e\
    \n\n\n\x02\x04\x02\x12\x04\x0e\0\x14\x01\n\n\n\x03\x04\x02\x01\x12\x03\
    \x0e\x08\x11\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x0f\x02\x0f\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03\x0f\x02\x06\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03\x0f\x07\n\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x0f\r\x0e\n\x0b\n\
    \x04\x04\x02\x02\x01\x12\x03\x10\x02\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03\x10\x02\x06\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x10\x07\x0b\
    \n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x10\x0e\x0f\n\x0b\n\x04\x04\x02\
    \x02\x02\x12\x03\x11\x02\x11\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\x11\
    \x02\x06\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x11\x07\x0c\n\x0c\n\x05\
    \x04\x02\x02\x02\x03\x12\x03\x11\x0f\x10\n\x0b\n\x04\x04\x02\x02\x03\x12\
    \x03\x12\x02\x13\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03\x12\x02\x06\n\
    \x0c\n\x05\x04\x02\x02\x03\x01\x12\x03\x12\x07\x0e\n\x0c\n\x05\x04\x02\
    \x02\x03\x03\x12\x03\x12\x11\x12\n\x0b\n\x04\x04\x02\x02\x04\x12\x03\x13\
    \x02\x13\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03\x13\x02\x06\n\x0c\n\x05\
    \x04\x02\x02\x04\x01\x12\x03\x13\x07\x0e\n\x0c\n\x05\x04\x02\x02\x04\x03\
    \x12\x03\x13\x11\x12\n\n\n\x02\x05\0\x12\x04\x16\0o\x01\n\n\n\x03\x05\0\
    \x01\x12\x03\x16\x05\x0c\n\x0b\n\x04\x05\0\x02\0\x12\x03\x17\x02\x0e\n\
    \x0c\n\x05\x05\0\x02\0\x01\x12\x03\x17\x02\t\n\x0c\n\x05\x05\0\x02\0\x02\
    \x12\x03\x17\x0c\r\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x18\x02\x10\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03\x18\x02\x0b\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03\x18\x0e\x0f\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x19\x02\x10\n\x0c\
    \n\x05\x05\0\x02\x02\x01\x12\x03\x19\x02\x0b\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03\x19\x0e\x0f\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x1a\x02\x11\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x1a\x02\x0c\n\x0c\n\x05\x05\0\x02\
    \x03\x02\x12\x03\x1a\x0f\x10\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x1b\x02\
    \x0e\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x1b\x02\t\n\x0c\n\x05\x05\0\
    \x02\x04\x02\x12\x03\x1b\x0c\r\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x1d\x02\
    \r\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x1d\x02\x08\n\x0c\n\x05\x05\0\
    \x02\x05\x02\x12\x03\x1d\x0b\x0c\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x1e\
    \x02\n\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x1e\x02\x05\n\x0c\n\x05\x05\
    \0\x02\x06\x02\x12\x03\x1e\x08\t\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x1f\
    \x02\x10\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x1f\x02\x0b\n\x0c\n\x05\
    \x05\0\x02\x07\x02\x12\x03\x1f\x0e\x0f\n\x0b\n\x04\x05\0\x02\x08\x12\x03\
    \x20\x02\x0c\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x20\x02\x07\n\x0c\n\
    \x05\x05\0\x02\x08\x02\x12\x03\x20\n\x0b\n\x0b\n\x04\x05\0\x02\t\x12\x03\
    !\x02\x0c\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03!\x02\x07\n\x0c\n\x05\x05\0\
    \x02\t\x02\x12\x03!\n\x0b\n\x0b\n\x04\x05\0\x02\n\x12\x03#\x02\x0e\n\x0c\
    \n\x05\x05\0\x02\n\x01\x12\x03#\x02\x08\n\x0c\n\x05\x05\0\x02\n\x02\x12\
    \x03#\x0b\r\n\x0b\n\x04\x05\0\x02\x0b\x12\x03$\x02\x0e\n\x0c\n\x05\x05\0\
    \x02\x0b\x01\x12\x03$\x02\x08\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03$\x0b\
    \r\n\x0b\n\x04\x05\0\x02\x0c\x12\x03%\x02\x0c\n\x0c\n\x05\x05\0\x02\x0c\
    \x01\x12\x03%\x02\x06\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03%\t\x0b\n\x0b\
    \n\x04\x05\0\x02\r\x12\x03&\x02\x0b\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03&\
    \x02\x05\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03&\x08\n\n\x0b\n\x04\x05\0\
    \x02\x0e\x12\x03'\x02\x0e\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03'\x02\x08\
    \n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03'\x0b\r\n\x0b\n\x04\x05\0\x02\x0f\
    \x12\x03(\x02\x10\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03(\x02\n\n\x0c\n\
    \x05\x05\0\x02\x0f\x02\x12\x03(\r\x0f\n<\n\x04\x05\0\x02\x10\x12\x03+\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03+\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x10\x02\x12\x03+\t\x0b\n<\n\x04\x05\0\x02\x11\x12\x03-\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03-\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x11\x02\x12\x03-\t\x0b\n<\n\x04\x05\0\x02\x12\x12\x03/\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03/\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x12\x02\x12\x03/\t\x0b\n<\n\x04\x05\0\x02\x13\x12\x031\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x031\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x13\x02\x12\x031\t\x0b\n<\n\x04\x05\0\x02\x14\x12\x033\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x033\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x14\x02\x12\x033\t\x0b\n<\n\x04\x05\0\x02\x15\x12\x035\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x035\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x15\x02\x12\x035\t\x0b\n<\n\x04\x05\0\x02\x16\x12\x037\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x037\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x16\x02\x12\x037\t\x0b\n<\n\x04\x05\0\x02\x17\x12\x039\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x039\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x17\x02\x12\x039\t\x0b\n<\n\x04\x05\0\x02\x18\x12\x03;\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03;\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x18\x02\x12\x03;\t\x0b\n<\n\x04\x05\0\x02\x19\x12\x03=\
    \x02\x0c\x1a//\x20Either\x20from\x20the\x20main\x20row\x20or\x20from\x20\
    the\x20numpad.\n\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03=\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x19\x02\x12\x03=\t\x0b\n*\n\x04\x05\0\x02\x1a\x12\x03?\
    \x02\t\"\x1d\x20Used\x20for\x20cmd+A\x20(select\x20All)\n\n\x0c\n\x05\
    \x05\0\x02\x1a\x01\x12\x03?\x02\x03\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\
    \x03?\x06\x08\n\x0b\n\x04\x05\0\x02\x1b\x12\x03@\x02\t\n\x0c\n\x05\x05\0\
    \x02\x1b\x01\x12\x03@\x02\x03\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03@\x06\
    \x08\n\x19\n\x04\x05\0\x02\x1c\x12\x03A\x02\t\"\x0c\x20|CMD\x20COPY|\n\n\
    \x0c\n\x05\x05\0\x02\x1c\x01\x12\x03A\x02\x03\n\x0c\n\x05\x05\0\x02\x1c\
    \x02\x12\x03A\x06\x08\n\x1d\n\x04\x05\0\x02\x1d\x12\x03B\x02\t\"\x10\x20\
    |CMD\x20BOOKMARK|\n\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03B\x02\x03\n\x0c\
    \n\x05\x05\0\x02\x1d\x02\x12\x03B\x06\x08\n\x1b\n\x04\x05\0\x02\x1e\x12\
    \x03C\x02\t\"\x0e\x20|CMD\x20SEARCH|\n\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\
    \x03C\x02\x03\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x03C\x06\x08\n*\n\x04\
    \x05\0\x02\x1f\x12\x03D\x02\t\"\x1d\x20|CMD\x20FIND\x20firefox\x20&\x20c\
    hrome|\n\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x03D\x02\x03\n\x0c\n\x05\x05\
    \0\x02\x1f\x02\x12\x03D\x06\x08\n\x20\n\x04\x05\0\x02\x20\x12\x03E\x02\t\
    \"\x13\x20|CMD\x20FIND\x20chrome|\n\n\x0c\n\x05\x05\0\x02\x20\x01\x12\
    \x03E\x02\x03\n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03E\x06\x08\n\x1c\n\x04\
    \x05\0\x02!\x12\x03F\x02\t\"\x0f\x20|CMD\x20History|\n\n\x0c\n\x05\x05\0\
    \x02!\x01\x12\x03F\x02\x03\n\x0c\n\x05\x05\0\x02!\x02\x12\x03F\x06\x08\n\
    \x16\n\x04\x05\0\x02\"\x12\x03G\x02\t\"\t\x20italics\n\n\x0c\n\x05\x05\0\
    \x02\"\x01\x12\x03G\x02\x03\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03G\x06\x08\
    \n3\n\x04\x05\0\x02#\x12\x03H\x02\t\"&\x20|CMD\x20SEARCH\x20firefox/DOWN\
    LOAD\x20chrome|\n\n\x0c\n\x05\x05\0\x02#\x01\x12\x03H\x02\x03\n\x0c\n\
    \x05\x05\0\x02#\x02\x12\x03H\x06\x08\n9\n\x04\x05\0\x02$\x12\x03I\x02\t\
    \",\x20Used\x20for\x20ctrl+K\x20(delete\x20text\x20after\x20cursor)\n\n\
    \x0c\n\x05\x05\0\x02$\x01\x12\x03I\x02\x03\n\x0c\n\x05\x05\0\x02$\x02\
    \x12\x03I\x06\x08\n\x0b\n\x04\x05\0\x02%\x12\x03J\x02\t\n\x0c\n\x05\x05\
    \0\x02%\x01\x12\x03J\x02\x03\n\x0c\n\x05\x05\0\x02%\x02\x12\x03J\x06\x08\
    \n\x0b\n\x04\x05\0\x02&\x12\x03K\x02\t\n\x0c\n\x05\x05\0\x02&\x01\x12\
    \x03K\x02\x03\n\x0c\n\x05\x05\0\x02&\x02\x12\x03K\x06\x08\n\x0b\n\x04\
    \x05\0\x02'\x12\x03L\x02\t\n\x0c\n\x05\x05\0\x02'\x01\x12\x03L\x02\x03\n\
    \x0c\n\x05\x05\0\x02'\x02\x12\x03L\x06\x08\n\x19\n\x04\x05\0\x02(\x12\
    \x03M\x02\t\"\x0c\x20|CMD\x20OPEN|\n\n\x0c\n\x05\x05\0\x02(\x01\x12\x03M\
    \x02\x03\n\x0c\n\x05\x05\0\x02(\x02\x12\x03M\x06\x08\n\x1a\n\x04\x05\0\
    \x02)\x12\x03N\x02\t\"\r\x20|CMD\x20PRINT|\n\n\x0c\n\x05\x05\0\x02)\x01\
    \x12\x03N\x02\x03\n\x0c\n\x05\x05\0\x02)\x02\x12\x03N\x06\x08\n\x0b\n\
    \x04\x05\0\x02*\x12\x03O\x02\t\n\x0c\n\x05\x05\0\x02*\x01\x12\x03O\x02\
    \x03\n\x0c\n\x05\x05\0\x02*\x02\x12\x03O\x06\x08\n\x1c\n\x04\x05\0\x02+\
    \x12\x03P\x02\t\"\x0f\x20|CMD\x20REFRESH|\n\n\x0c\n\x05\x05\0\x02+\x01\
    \x12\x03P\x02\x03\n\x0c\n\x05\x05\0\x02+\x02\x12\x03P\x06\x08\n\x19\n\
    \x04\x05\0\x02,\x12\x03Q\x02\t\"\x0c\x20|CMD\x20SAVE|\n\n\x0c\n\x05\x05\
    \0\x02,\x01\x12\x03Q\x02\x03\n\x0c\n\x05\x05\0\x02,\x02\x12\x03Q\x06\x08\
    \n\x18\n\x04\x05\0\x02-\x12\x03R\x02\t\"\x0b\x20|CMD\x20TAB|\n\n\x0c\n\
    \x05\x05\0\x02-\x01\x12\x03R\x02\x03\n\x0c\n\x05\x05\0\x02-\x02\x12\x03R\
    \x06\x08\n:\n\x04\x05\0\x02.\x12\x03S\x02\t\"-\x20Used\x20for\x20ctrl+U\
    \x20(delete\x20text\x20before\x20cursor)\n\n\x0c\n\x05\x05\0\x02.\x01\
    \x12\x03S\x02\x03\n\x0c\n\x05\x05\0\x02.\x02\x12\x03S\x06\x08\n\x1a\n\
    \x04\x05\0\x02/\x12\x03T\x02\t\"\r\x20|CMD\x20PASTE|\n\n\x0c\n\x05\x05\0\
    \x02/\x01\x12\x03T\x02\x03\n\x0c\n\x05\x05\0\x02/\x02\x12\x03T\x06\x08\n\
    5\n\x04\x05\0\x020\x12\x03U\x02\t\"(\x20Used\x20for\x20ctrl+W\x20(delete\
    \x20previous\x20word)\n\n\x0c\n\x05\x05\0\x020\x01\x12\x03U\x02\x03\n\
    \x0c\n\x05\x05\0\x020\x02\x12\x03U\x06\x08\n\x18\n\x04\x05\0\x021\x12\
    \x03V\x02\t\"\x0b\x20|CMD\x20CUT|\n\n\x0c\n\x05\x05\0\x021\x01\x12\x03V\
    \x02\x03\n\x0c\n\x05\x05\0\x021\x02\x12\x03V\x06\x08\n\x0b\n\x04\x05\0\
    \x022\x12\x03W\x02\t\n\x0c\n\x05\x05\0\x022\x01\x12\x03W\x02\x03\n\x0c\n\
    \x05\x05\0\x022\x02\x12\x03W\x06\x08\n\x19\n\x04\x05\0\x023\x12\x03X\x02\
    \t\"\x0c\x20|CMD\x20UNDO|\n\n\x0c\n\x05\x05\0\x023\x01\x12\x03X\x02\x03\
    \n\x0c\n\x05\x05\0\x023\x02\x12\x03X\x06\x08\n!\n\x04\x05\0\x024\x12\x03\
    [\x02\n\x1a\x14\x20The\x20function\x20keys:\n\n\x0c\n\x05\x05\0\x024\x01\
    \x12\x03[\x02\x04\n\x0c\n\x05\x05\0\x024\x02\x12\x03[\x07\t\n\x0b\n\x04\
    \x05\0\x025\x12\x03\\\x02\n\n\x0c\n\x05\x05\0\x025\x01\x12\x03\\\x02\x04\
    \n\x0c\n\x05\x05\0\x025\x02\x12\x03\\\x07\t\n\x0b\n\x04\x05\0\x026\x12\
    \x03]\x02\n\n\x0c\n\x05\x05\0\x026\x01\x12\x03]\x02\x04\n\x0c\n\x05\x05\
    \0\x026\x02\x12\x03]\x07\t\n\x0b\n\x04\x05\0\x027\x12\x03^\x02\n\n\x0c\n\
    \x05\x05\0\x027\x01\x12\x03^\x02\x04\n\x0c\n\x05\x05\0\x027\x02\x12\x03^\
    \x07\t\n\x1c\n\x04\x05\0\x028\x12\x03_\x02\n\"\x0f\x20|CMD\x20REFRESH|\n\
    \n\x0c\n\x05\x05\0\x028\x01\x12\x03_\x02\x04\n\x0c\n\x05\x05\0\x028\x02\
    \x12\x03_\x07\t\n\x0b\n\x04\x05\0\x029\x12\x03`\x02\n\n\x0c\n\x05\x05\0\
    \x029\x01\x12\x03`\x02\x04\n\x0c\n\x05\x05\0\x029\x02\x12\x03`\x07\t\n\
    \x0b\n\x04\x05\0\x02:\x12\x03a\x02\n\n\x0c\n\x05\x05\0\x02:\x01\x12\x03a\
    \x02\x04\n\x0c\n\x05\x05\0\x02:\x02\x12\x03a\x07\t\n\x0b\n\x04\x05\0\x02\
    ;\x12\x03b\x02\n\n\x0c\n\x05\x05\0\x02;\x01\x12\x03b\x02\x04\n\x0c\n\x05\
    \x05\0\x02;\x02\x12\x03b\x07\t\n\x0b\n\x04\x05\0\x02<\x12\x03c\x02\n\n\
    \x0c\n\x05\x05\0\x02<\x01\x12\x03c\x02\x04\n\x0c\n\x05\x05\0\x02<\x02\
    \x12\x03c\x07\t\n\x0b\n\x04\x05\0\x02=\x12\x03d\x02\x0b\n\x0c\n\x05\x05\
    \0\x02=\x01\x12\x03d\x02\x05\n\x0c\n\x05\x05\0\x02=\x02\x12\x03d\x08\n\n\
    \x0b\n\x04\x05\0\x02>\x12\x03e\x02\x0b\n\x0c\n\x05\x05\0\x02>\x01\x12\
    \x03e\x02\x05\n\x0c\n\x05\x05\0\x02>\x02\x12\x03e\x08\n\n\x0b\n\x04\x05\
    \0\x02?\x12\x03f\x02\x0b\n\x0c\n\x05\x05\0\x02?\x01\x12\x03f\x02\x05\n\
    \x0c\n\x05\x05\0\x02?\x02\x12\x03f\x08\n\n\x0b\n\x04\x05\0\x02@\x12\x03g\
    \x02\x0b\n\x0c\n\x05\x05\0\x02@\x01\x12\x03g\x02\x05\n\x0c\n\x05\x05\0\
    \x02@\x02\x12\x03g\x08\n\n\x0b\n\x04\x05\0\x02A\x12\x03h\x02\x0b\n\x0c\n\
    \x05\x05\0\x02A\x01\x12\x03h\x02\x05\n\x0c\n\x05\x05\0\x02A\x02\x12\x03h\
    \x08\n\n\x0b\n\x04\x05\0\x02B\x12\x03i\x02\x0b\n\x0c\n\x05\x05\0\x02B\
    \x01\x12\x03i\x02\x05\n\x0c\n\x05\x05\0\x02B\x02\x12\x03i\x08\n\n\x0b\n\
    \x04\x05\0\x02C\x12\x03j\x02\x0b\n\x0c\n\x05\x05\0\x02C\x01\x12\x03j\x02\
    \x05\n\x0c\n\x05\x05\0\x02C\x02\x12\x03j\x08\n\n\x0b\n\x04\x05\0\x02D\
    \x12\x03k\x02\x0b\n\x0c\n\x05\x05\0\x02D\x01\x12\x03k\x02\x05\n\x0c\n\
    \x05\x05\0\x02D\x02\x12\x03k\x08\n\n\x0b\n\x04\x05\0\x02E\x12\x03l\x02\
    \x0b\n\x0c\n\x05\x05\0\x02E\x01\x12\x03l\x02\x05\n\x0c\n\x05\x05\0\x02E\
    \x02\x12\x03l\x08\n\n\x0b\n\x04\x05\0\x02F\x12\x03m\x02\x0b\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03m\x02\x05\n\x0c\n\x05\x05\0\x02F\x02\x12\x03m\x08\
    \n\n\x0b\n\x04\x05\0\x02G\x12\x03n\x02\x0b\n\x0c\n\x05\x05\0\x02G\x01\
    \x12\x03n\x02\x05\n\x0c\n\x05\x05\0\x02G\x02\x12\x03n\x08\n\n\n\n\x02\
    \x04\x03\x12\x04q\0u\x01\n\n\n\x03\x04\x03\x01\x12\x03q\x08\x0b\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03r\x02\x12\n\x0c\n\x05\x04\x03\x02\0\x06\x12\
    \x03r\x02\t\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03r\n\r\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03r\x10\x11\n\x0b\n\x04\x04\x03\x02\x01\x12\x03s\x02\
    \x13\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03s\x02\x06\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03s\x07\x0e\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\
    \x03s\x11\x12\n\x0b\n\x04\x04\x03\x02\x02\x12\x03t\x02\x1a\n\x0c\n\x05\
    \x04\x03\x02\x02\x06\x12\x03t\x02\x0b\n\x0c\n\x05\x04\x03\x02\x02\x01\
    \x12\x03t\x0c\x15\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03t\x18\x19\n\n\n\
    \x02\x05\x01\x12\x04w\0~\x01\n\n\n\x03\x05\x01\x01\x12\x03w\x05\x0f\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03x\x02\x0e\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x03x\x02\t\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03x\x0c\r\n\x0b\n\x04\
    \x05\x01\x02\x01\x12\x03y\x02\x0e\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\
    \x03y\x02\t\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03y\x0c\r\n\x0b\n\x04\
    \x05\x01\x02\x02\x12\x03z\x02\x10\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\
    \x03z\x02\x0b\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03z\x0e\x0f\n\x0b\n\
    \x04\x05\x01\x02\x03\x12\x03{\x02\r\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\
    \x03{\x02\x08\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03{\x0b\x0c\n\x0b\n\
    \x04\x05\x01\x02\x04\x12\x03|\x02\r\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\
    \x03|\x02\x08\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03|\x0b\x0c\n\x0b\n\
    \x04\x05\x01\x02\x05\x12\x03}\x02\r\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\
    \x03}\x02\x08\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03}\x0b\x0c\n\x0c\n\
    \x02\x04\x04\x12\x06\x80\x01\0\x85\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\
    \x04\x80\x01\x08\x15\n\x0c\n\x04\x04\x04\x02\0\x12\x04\x81\x01\x02\x0f\n\
    \r\n\x05\x04\x04\x02\0\x06\x12\x04\x81\x01\x02\x06\n\r\n\x05\x04\x04\x02\
    \0\x01\x12\x04\x81\x01\x07\n\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x81\x01\
    \r\x0e\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\x82\x01\x02\x18\n\r\n\x05\x04\
    \x04\x02\x01\x06\x12\x04\x82\x01\x02\x0c\n\r\n\x05\x04\x04\x02\x01\x01\
    \x12\x04\x82\x01\r\x13\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x82\x01\x16\
    \x17\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\x83\x01\x02\x13\n\r\n\x05\x04\
    \x04\x02\x02\x05\x12\x04\x83\x01\x02\x06\n\r\n\x05\x04\x04\x02\x02\x01\
    \x12\x04\x83\x01\x07\x0e\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x83\x01\
    \x11\x12\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\x84\x01\x02\x1a\n\r\n\x05\
    \x04\x04\x02\x03\x06\x12\x04\x84\x01\x02\x0b\n\r\n\x05\x04\x04\x02\x03\
    \x01\x12\x04\x84\x01\x0c\x15\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\x84\
    \x01\x18\x19\n\x0c\n\x02\x05\x02\x12\x06\x87\x01\0\x8d\x01\x01\n\x0b\n\
    \x03\x05\x02\x01\x12\x04\x87\x01\x05\x0f\n\x0c\n\x04\x05\x02\x02\0\x12\
    \x04\x88\x01\x02\x0e\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\x88\x01\x02\t\n\
    \r\n\x05\x05\x02\x02\0\x02\x12\x04\x88\x01\x0c\r\n\x0c\n\x04\x05\x02\x02\
    \x01\x12\x04\x89\x01\x02\x0c\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\x89\
    \x01\x02\x07\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\x89\x01\n\x0b\n\x0c\n\
    \x04\x05\x02\x02\x02\x12\x04\x8a\x01\x02\x0b\n\r\n\x05\x05\x02\x02\x02\
    \x01\x12\x04\x8a\x01\x02\x06\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\x8a\
    \x01\t\n\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\x8b\x01\x02\n\n\r\n\x05\x05\
    \x02\x02\x03\x01\x12\x04\x8b\x01\x02\x05\n\r\n\x05\x05\x02\x02\x03\x02\
    \x12\x04\x8b\x01\x08\t\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\x8c\x01\x02\r\
    \n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\x8c\x01\x02\x08\n\r\n\x05\x05\x02\
    \x02\x04\x02\x12\x04\x8c\x01\x0b\x0c\n\x0c\n\x02\x04\x05\x12\x06\x8f\x01\
    \0\x95\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x8f\x01\x08\r\n\x0c\n\x04\
    \x04\x05\x02\0\x12\x04\x90\x01\x02\x17\n\r\n\x05\x04\x05\x02\0\x05\x12\
    \x04\x90\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x90\x01\t\x12\n\
    \r\n\x05\x04\x05\x02\0\x03\x12\x04\x90\x01\x15\x16\n\x0c\n\x04\x04\x05\
    \x02\x01\x12\x04\x91\x01\x02\x10\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\
    \x91\x01\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x91\x01\t\x0b\n\r\
    \n\x05\x04\x05\x02\x01\x03\x12\x04\x91\x01\x0e\x0f\n\x0c\n\x04\x04\x05\
    \x02\x02\x12\x04\x92\x01\x02\x17\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\
    \x92\x01\x02\x0c\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x92\x01\r\x12\n\r\
    \n\x05\x04\x05\x02\x02\x03\x12\x04\x92\x01\x15\x16\n\x0c\n\x04\x04\x05\
    \x02\x03\x12\x04\x93\x01\x02\x0f\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\
    \x93\x01\x02\x06\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x93\x01\x07\n\n\r\
    \n\x05\x04\x05\x02\x03\x03\x12\x04\x93\x01\r\x0e\n\x0c\n\x04\x04\x05\x02\
    \x04\x12\x04\x94\x01\x02\x12\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\x94\
    \x01\x02\x07\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\x94\x01\x08\r\n\r\n\
    \x05\x04\x05\x02\x04\x03\x12\x04\x94\x01\x10\x11\n\x0c\n\x02\x05\x03\x12\
    \x06\x97\x01\0\xa6\x01\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\x97\x01\x05\
    \x0e\n\x0c\n\x04\x05\x03\x02\0\x12\x04\x98\x01\x02\x0e\n\r\n\x05\x05\x03\
    \x02\0\x01\x12\x04\x98\x01\x02\t\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x98\
    \x01\x0c\r\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\x99\x01\x02\x0b\n\r\n\x05\
    \x05\x03\x02\x01\x01\x12\x04\x99\x01\x02\x06\n\r\n\x05\x05\x03\x02\x01\
    \x02\x12\x04\x99\x01\t\n\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\x9a\x01\x02\
    \n\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\x9a\x01\x02\x05\n\r\n\x05\x05\
    \x03\x02\x02\x02\x12\x04\x9a\x01\x08\t\n\x0c\n\x04\x05\x03\x02\x03\x12\
    \x04\x9b\x01\x02\x0c\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\x9b\x01\x02\
    \x07\n\r\n\x05\x05\x03\x02\x03\x02\x12\x04\x9b\x01\n\x0b\n\x0c\n\x04\x05\
    \x03\x02\x04\x12\x04\x9c\x01\x02\x0b\n\r\n\x05\x05\x03\x02\x04\x01\x12\
    \x04\x9c\x01\x02\x06\n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\x9c\x01\t\n\n\
    \x0c\n\x04\x05\x03\x02\x05\x12\x04\x9d\x01\x02\n\n\r\n\x05\x05\x03\x02\
    \x05\x01\x12\x04\x9d\x01\x02\x05\n\r\n\x05\x05\x03\x02\x05\x02\x12\x04\
    \x9d\x01\x08\t\n\x0c\n\x04\x05\x03\x02\x06\x12\x04\x9e\x01\x02\x14\n\r\n\
    \x05\x05\x03\x02\x06\x01\x12\x04\x9e\x01\x02\x0f\n\r\n\x05\x05\x03\x02\
    \x06\x02\x12\x04\x9e\x01\x12\x13\n\x0c\n\x04\x05\x03\x02\x07\x12\x04\x9f\
    \x01\x02\x15\n\r\n\x05\x05\x03\x02\x07\x01\x12\x04\x9f\x01\x02\x10\n\r\n\
    \x05\x05\x03\x02\x07\x02\x12\x04\x9f\x01\x13\x14\n\x0c\n\x04\x05\x03\x02\
    \x08\x12\x04\xa0\x01\x02\x13\n\r\n\x05\x05\x03\x02\x08\x01\x12\x04\xa0\
    \x01\x02\x0e\n\r\n\x05\x05\x03\x02\x08\x02\x12\x04\xa0\x01\x11\x12\n\x0c\
    \n\x04\x05\x03\x02\t\x12\x04\xa1\x01\x02\x0e\n\r\n\x05\x05\x03\x02\t\x01\
    \x12\x04\xa1\x01\x02\x08\n\r\n\x05\x05\x03\x02\t\x02\x12\x04\xa1\x01\x0b\
    \r\n\x0c\n\x04\x05\x03\x02\n\x12\x04\xa2\x01\x02\x0c\n\r\n\x05\x05\x03\
    \x02\n\x01\x12\x04\xa2\x01\x02\x06\n\r\n\x05\x05\x03\x02\n\x02\x12\x04\
    \xa2\x01\t\x0b\n\x0c\n\x04\x05\x03\x02\x0b\x12\x04\xa3\x01\x02\x19\n\r\n\
    \x05\x05\x03\x02\x0b\x01\x12\x04\xa3\x01\x02\x13\n\r\n\x05\x05\x03\x02\
    \x0b\x02\x12\x04\xa3\x01\x16\x18\n\x0c\n\x04\x05\x03\x02\x0c\x12\x04\xa4\
    \x01\x02\x1a\n\r\n\x05\x05\x03\x02\x0c\x01\x12\x04\xa4\x01\x02\x14\n\r\n\
    \x05\x05\x03\x02\x0c\x02\x12\x04\xa4\x01\x17\x19\n\x0c\n\x04\x05\x03\x02\
    \r\x12\x04\xa5\x01\x02\r\n\r\n\x05\x05\x03\x02\r\x01\x12\x04\xa5\x01\x02\
    \x07\n\r\n\x05\x05\x03\x02\r\x02\x12\x04\xa5\x01\n\x0c\n\x0c\n\x02\x04\
    \x06\x12\x06\xa8\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xa8\
    \x01\x08\r\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xa9\x01\x02\x13\n\r\n\x05\
    \x04\x06\x02\0\x06\x12\x04\xa9\x01\x02\x0b\n\r\n\x05\x04\x06\x02\0\x01\
    \x12\x04\xa9\x01\x0c\x0e\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xa9\x01\x11\
    \x12\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xaa\x01\x02\x10\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xaa\x01\x02\x06\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xaa\x01\x07\x0b\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xaa\x01\
    \x0e\x0f\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xab\x01\x02\x0f\n\r\n\x05\
    \x04\x06\x02\x02\x05\x12\x04\xab\x01\x02\x06\n\r\n\x05\x04\x06\x02\x02\
    \x01\x12\x04\xab\x01\x07\n\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xab\x01\
    \r\x0e\n\x0c\n\x04\x04\x06\x02\x03\x12\x04\xac\x01\x02\x13\n\r\n\x05\x04\
    \x06\x02\x03\x05\x12\x04\xac\x01\x02\x08\n\r\n\x05\x04\x06\x02\x03\x01\
    \x12\x04\xac\x01\t\x0e\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xac\x01\x11\
    \x12\n\x0c\n\x04\x04\x06\x02\x04\x12\x04\xad\x01\x02\x12\n\r\n\x05\x04\
    \x06\x02\x04\x05\x12\x04\xad\x01\x02\x08\n\r\n\x05\x04\x06\x02\x04\x01\
    \x12\x04\xad\x01\t\r\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\xad\x01\x10\
    \x11\n\x0c\n\x04\x04\x06\x02\x05\x12\x04\xae\x01\x02\x0e\n\r\n\x05\x04\
    \x06\x02\x05\x06\x12\x04\xae\x01\x02\x05\n\r\n\x05\x04\x06\x02\x05\x01\
    \x12\x04\xae\x01\x06\t\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xae\x01\x0c\
    \r\n\x0c\n\x04\x04\x06\x02\x06\x12\x04\xaf\x01\x02\x19\n\r\n\x05\x04\x06\
    \x02\x06\x06\x12\x04\xaf\x01\x02\x06\n\r\n\x05\x04\x06\x02\x06\x01\x12\
    \x04\xaf\x01\x07\x14\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\xaf\x01\x17\
    \x18\n\x0c\n\x04\x04\x06\x02\x07\x12\x04\xb0\x01\x02#\n\r\n\x05\x04\x06\
    \x02\x07\x06\x12\x04\xb0\x01\x02\x0f\n\r\n\x05\x04\x06\x02\x07\x01\x12\
    \x04\xb0\x01\x10\x1e\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\xb0\x01!\"\n\
    \x0c\n\x04\x04\x06\x02\x08\x12\x04\xb1\x01\x02\x18\n\r\n\x05\x04\x06\x02\
    \x08\x05\x12\x04\xb1\x01\x02\x06\n\r\n\x05\x04\x06\x02\x08\x01\x12\x04\
    \xb1\x01\x07\x13\n\r\n\x05\x04\x06\x02\x08\x03\x12\x04\xb1\x01\x16\x17\n\
    \x0c\n\x04\x04\x06\x02\t\x12\x04\xb2\x01\x02\x13\n\r\n\x05\x04\x06\x02\t\
    \x06\x12\x04\xb2\x01\x02\x06\n\r\n\x05\x04\x06\x02\t\x01\x12\x04\xb2\x01\
    \x07\r\n\r\n\x05\x04\x06\x02\t\x03\x12\x04\xb2\x01\x10\x12\n\x0c\n\x04\
    \x04\x06\x02\n\x12\x04\xb3\x01\x02\x12\n\r\n\x05\x04\x06\x02\n\x05\x12\
    \x04\xb3\x01\x02\x07\n\r\n\x05\x04\x06\x02\n\x01\x12\x04\xb3\x01\x08\x0c\
    \n\r\n\x05\x04\x06\x02\n\x03\x12\x04\xb3\x01\x0f\x11\n\x0c\n\x04\x04\x06\
    \x02\x0b\x12\x04\xb4\x01\x02\x1e\n\r\n\x05\x04\x06\x02\x0b\x05\x12\x04\
    \xb4\x01\x02\x06\n\r\n\x05\x04\x06\x02\x0b\x01\x12\x04\xb4\x01\x07\x18\n\
    \r\n\x05\x04\x06\x02\x0b\x03\x12\x04\xb4\x01\x1b\x1d\n\x0c\n\x04\x04\x06\
    \x02\x0c\x12\x04\xb5\x01\x02!\n\r\n\x05\x04\x06\x02\x0c\x05\x12\x04\xb5\
    \x01\x02\x08\n\r\n\x05\x04\x06\x02\x0c\x01\x12\x04\xb5\x01\t\x1b\n\r\n\
    \x05\x04\x06\x02\x0c\x03\x12\x04\xb5\x01\x1e\x20\n\x0c\n\x04\x04\x06\x02\
    \r\x12\x04\xb6\x01\x02\x13\n\r\n\x05\x04\x06\x02\r\x06\x12\x04\xb6\x01\
    \x02\x07\n\r\n\x05\x04\x06\x02\r\x01\x12\x04\xb6\x01\x08\r\n\r\n\x05\x04\
    \x06\x02\r\x03\x12\x04\xb6\x01\x10\x12\n\x0c\n\x02\x04\x07\x12\x06\xb9\
    \x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb9\x01\x08\r\n\x0c\n\
    \x04\x04\x07\x02\0\x12\x04\xba\x01\x02\x17\n\r\n\x05\x04\x07\x02\0\x06\
    \x12\x04\xba\x01\x02\x06\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xba\x01\x07\
    \x12\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xba\x01\x15\x16\n\x0c\n\x04\x04\
    \x07\x02\x01\x12\x04\xbb\x01\x02\x1d\n\r\n\x05\x04\x07\x02\x01\x05\x12\
    \x04\xbb\x01\x02\x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xbb\x01\x08\
    \x18\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xbb\x01\x1b\x1c\n\x0c\n\x04\
    \x04\x07\x02\x02\x12\x04\xbc\x01\x02\x1e\n\r\n\x05\x04\x07\x02\x02\x05\
    \x12\x04\xbc\x01\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xbc\x01\t\
    \x19\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xbc\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x07\x02\x03\x12\x04\xbd\x01\x02\x12\n\r\n\x05\x04\x07\x02\x03\x05\
    \x12\x04\xbd\x01\x02\x08\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xbd\x01\t\
    \r\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xbd\x01\x10\x11\n\x0c\n\x04\x04\
    \x07\x02\x04\x12\x04\xbe\x01\x02\x19\n\r\n\x05\x04\x07\x02\x04\x05\x12\
    \x04\xbe\x01\x02\x07\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xbe\x01\x08\
    \x14\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\xbe\x01\x17\x18\n\x0c\n\x04\
    \x04\x07\x02\x05\x12\x04\xbf\x01\x02\x1d\n\r\n\x05\x04\x07\x02\x05\x04\
    \x12\x04\xbf\x01\x02\n\n\r\n\x05\x04\x07\x02\x05\x06\x12\x04\xbf\x01\x0c\
    \x11\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\xbf\x01\x12\x18\n\r\n\x05\x04\
    \x07\x02\x05\x03\x12\x04\xbf\x01\x1b\x1c\n\x0c\n\x04\x04\x07\x02\x06\x12\
    \x04\xc0\x01\x02\x15\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\xc0\x01\x02\
    \x06\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\xc0\x01\x07\x10\n\r\n\x05\x04\
    \x07\x02\x06\x03\x12\x04\xc0\x01\x13\x14\n\x0c\n\x04\x04\x07\x02\x07\x12\
    \x04\xc1\x01\x02\x19\n\r\n\x05\x04\x07\x02\x07\x06\x12\x04\xc1\x01\x02\
    \x0b\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xc1\x01\x0c\x14\n\r\n\x05\x04\
    \x07\x02\x07\x03\x12\x04\xc1\x01\x17\x18b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(Pos2::generated_message_descriptor_data());
            messages.push(Rect::generated_message_descriptor_data());
            messages.push(Modifiers::generated_message_descriptor_data());
            messages.push(Key::generated_message_descriptor_data());
            messages.push(PointerButton::generated_message_descriptor_data());
            messages.push(Touch::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(Input::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(KeyType::generated_enum_descriptor_data());
            enums.push(ButtonType::generated_enum_descriptor_data());
            enums.push(TouchPhase::generated_enum_descriptor_data());
            enums.push(EventType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
